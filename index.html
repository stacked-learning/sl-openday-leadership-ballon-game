<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Barlow:wght@400;600;700&display=swap" rel="stylesheet">
    <meta charset="UTF-8" />
  <title>Balloon Anchor Playground</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      height: 100vh;
      font-family: "Barlow", "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      background: radial-gradient(circle at top, #f8fbff 0%, #e8edf5 55%, #dee3ee 100%);
      color: #2a2f3e;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      overflow: hidden;
    }

    main {
      flex: 1 1 auto;
      width: 100%;
      height: 100vh;
      min-height: 100vh;
      padding: clamp(1rem, 3vw, 2.5rem);
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      position: relative;
    }

    h1 {
      margin: 0;
      text-align: center;
      font-size: clamp(1.5rem, 4vw, 2.5rem);
      letter-spacing: 0.04em;
      color: #26324d;
    }

    .subtitle {
      text-align: center;
      margin: 0;
      font-size: 1rem;
      color: #4a5062;
    }

    .field {
      flex: 1 1 auto;
      width: 100%;
      min-height: 0;
      position: relative;
      z-index: 2;
      overflow: visible;
      border-radius: 28px;
      background: linear-gradient(145deg, #f4f7fc 0%, #dfe6f3 100%);
      border: 2px solid rgba(70, 92, 124, 0.15);
      box-shadow: 0 25px 45px rgba(35, 47, 73, 0.12);
    }

    .balloon {
      --fill: #ff9aa2;
      --balloon-scale: 1;
      --fx1: 0px;
      --fy1: 0px;
      --fx2: 0px;
      --fy2: 0px;
      --fx3: 0px;
      --fy3: 0px;
      --ax1: 0px;
      --ay1: 0px;
      --ax2: 0px;
      --ay2: 0px;
      position: absolute;
      width: calc(var(--balloon-width, 125px) * var(--balloon-scale));
      height: calc(var(--balloon-height, 130px) * var(--balloon-scale));
      border-radius: var(--balloon-radius, 48% 52% 55% 45% / 40% 42% 58% 60%);
      background:
        radial-gradient(circle at 30% 25%, rgba(255, 255, 255, 0.35), rgba(255, 255, 255, 0) 55%),
        linear-gradient(145deg, rgba(255, 255, 255, 0.08), rgba(0, 0, 0, 0.1)),
        var(--fill);
      color: #fff;
      font-weight: 600;
      font-size: 0.92rem;
      line-height: 1.3;
      text-align: center;
      padding: 0.85rem;
      display: flex;
      align-items: center;
      justify-content: center;
      word-break: break-word;
      white-space: normal;
      box-shadow: 0 14px 24px rgba(37, 49, 74, 0.25);
      cursor: grab;
      user-select: none;
      touch-action: none;
      transition: left 0.25s ease, top 0.25s ease, transform 0.2s ease, box-shadow 0.2s ease;
      animation: none;
      overflow: visible;
      isolation: isolate;
    }

    .balloon::before {
      content: "";
      position: absolute;
      width: 18px;
      height: 16px;
      bottom: -6px;
      left: 50%;
      transform: translateX(-50%) rotate(6deg);
      background: var(--fill);
      border-radius: 40% 40% 65% 65%;
      box-shadow: inset 0 -2px 4px rgba(0, 0, 0, 0.1);
      pointer-events: none;
    }

    .balloon::after {
      content: "";
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: -80px;
      width: 26px;
      height: 90px;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='80' viewBox='0 0 24 80'%3E%3Cpath d='M12 0 C4 10 20 20 12 32 C4 44 20 54 12 64 C6 72 18 76 14 80' stroke='%23a0a8c2' stroke-width='2.4' fill='none' stroke-linecap='round'/%3E%3C/svg%3E");
      background-size: contain;
      background-repeat: no-repeat;
      pointer-events: none;
    }

    .balloon.dragging {
      cursor: grabbing;
      transform: scale(1.08);
      animation-play-state: paused;
      box-shadow: 0 20px 34px rgba(24, 32, 51, 0.35);
    }

    .balloon.allowed {
      filter: brightness(0.9);
    }

    .balloon.anchored {
      position: relative;
      width: calc(var(--balloon-width, 125px) * var(--balloon-scale) * 0.82);
      height: calc(var(--balloon-height, 130px) * var(--balloon-scale) * 0.82);
      border-radius: var(--balloon-radius, 48% 52% 55% 45% / 40% 42% 58% 60%);
      cursor: pointer;
      pointer-events: auto;
      animation: anchoredFloat 10s ease-in-out infinite;
      animation-play-state: running;
    }

    .balloon.anchored.anchoring {
      animation: none;
    }

    .balloon.anchored::before {
      bottom: -4px;
      width: 14px;
      height: 12px;
    }

    .balloon.anchored::after {
      bottom: -60px;
      height: 70px;
    }

    .balloon-label {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0.4rem;
      z-index: 2;
      pointer-events: none;
      text-align: center;
      white-space: normal;
    }

    .anchor-area {
      flex: 0 0 auto;
      padding-bottom: 1rem;
      position: relative;
      z-index: 1;
    }

    .anchor-status {
      margin: 0;
      text-align: center;
      font-weight: 600;
      color: #4c536b;
      letter-spacing: 0.05em;
    }

    .dropzone {
      margin-top: 0.65rem;
      border-radius: 20px;
      border: 2px dashed rgba(57, 73, 100, 0.4);
      background: rgba(255, 255, 255, 0.8);
      padding: 1.2rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      transition: border-color 0.2s ease, background 0.2s ease;
      min-height: 170px;
      overflow: visible;
    }

    .dropzone.ready {
      border-color: #2eb086;
      background: rgba(206, 244, 225, 0.8);
    }

    .dropzone.full {
      border-color: #ea4c4c;
    }

    .dropzone label {
      font-size: 0.9rem;
      font-weight: 600;
      color: #515562;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .anchor-slot {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      min-height: 90px;
      align-items: center;
      overflow: visible;
    }

    .floating-actions {
      position: absolute;
      top: clamp(0.75rem, 2vw, 1.25rem);
      right: clamp(0.75rem, 2vw, 1.5rem);
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      justify-content: flex-end;
      z-index: 60;
    }

    .floating-actions .ghost-btn,
    .floating-actions .primary-btn {
      padding: 0.45rem 1.1rem;
      font-size: 0.9rem;
    }

    .floating-actions button[hidden] {
      display: none;
    }

    .brand {
      position: absolute;
      top: clamp(0.75rem, 2vw, 1.25rem);
      left: clamp(0.75rem, 2vw, 1.5rem);
      z-index: 70;
    }

    .brand img {
      height: clamp(40px, 12vw, 70px);
      width: auto;
      display: block;
    }


    .completion-overlay {
      position: fixed;
      inset: 0;
      background: rgba(14, 23, 38, 0.5);
      backdrop-filter: blur(6px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 200;
      padding: 1rem;
    }

    .completion-overlay.active {
      display: flex;
    }

    .completion-card {
      background: #fff;
      border-radius: 24px;
      padding: 2rem;
      max-width: 420px;
      text-align: center;
      box-shadow: 0 20px 45px rgba(20, 30, 55, 0.35);
      animation: pop 0.3s ease;
    }

    .completion-card h2 {
      margin: 0 0 0.5rem;
      font-size: 1.8rem;
      color: #25304a;
    }

    .completion-card p {
      margin: 0 0 1.5rem;
      color: #4e5568;
      font-size: 1rem;
    }

    .completion-actions {
      display: flex;
      gap: 0.75rem;
      justify-content: center;
      flex-wrap: wrap;
    }

    .primary-btn,
    .ghost-btn {
      border: none;
      border-radius: 14px;
      padding: 0.7rem 1.4rem;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .primary-btn {
      background: linear-gradient(135deg, #5d8bf4, #4fd1c5);
      color: #fff;
      box-shadow: 0 10px 20px rgba(74, 133, 236, 0.35);
    }

    .ghost-btn {
      background: #f5f7ff;
      color: #42506d;
      border: 1px solid rgba(66, 80, 109, 0.2);
    }

    .primary-btn:active,
    .ghost-btn:active {
      transform: translateY(1px);
    }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(12, 17, 29, 0.55);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      z-index: 250;
    }

    .modal.active {
      display: flex;
    }

    .modal-dialog {
      background: #ffffff;
      border-radius: 32px;
      width: min(1100px, 95vw);
      max-height: 92vh;
      padding: 2.5rem 3rem;
      box-shadow: 0 25px 50px rgba(20, 30, 55, 0.4);
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .modal-close {
      position: absolute;
      top: 1rem;
      right: 1.5rem;
      border: none;
      background: none;
      font-size: 2rem;
      cursor: pointer;
      color: #8b94ac;
    }

    .carousel {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .carousel-viewport {
      overflow: hidden;
      flex: 1 1 auto;
    }

    .carousel-track {
      display: flex;
      transition: transform 0.4s ease;
      touch-action: pan-y;
    }

    .carousel-slide {
      width: 100%;
      display: flex;
      gap: 1.5rem;
      align-items: center;
      flex-shrink: 0;
    }

    .carousel-balloon {
      width: 220px;
      aspect-ratio: 3 / 4;
      border-radius: 48% 52% 60% 40% / 34% 40% 66% 66%;
      background: var(--fill, #ff8f87);
      background-image:
        radial-gradient(circle at 30% 25%, rgba(255, 255, 255, 0.35), rgba(255, 255, 255, 0) 60%),
        linear-gradient(145deg, rgba(255, 255, 255, 0.08), rgba(0, 0, 0, 0.1));
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-weight: 700;
      font-size: 1.2rem;
      text-align: center;
      padding: 1rem;
    }

    .carousel-balloon::before {
      content: "";
      position: absolute;
      bottom: -14px;
      left: 50%;
      transform: translateX(-50%) rotate(8deg);
      width: 28px;
      height: 20px;
      background: var(--fill, #ff8f87);
      border-radius: 45% 45% 70% 70%;
      box-shadow: inset 0 -2px 4px rgba(0, 0, 0, 0.12);
    }

    .carousel-balloon::after {
      content: "";
      position: absolute;
      bottom: -80px;
      left: 50%;
      transform: translateX(-50%);
      width: 28px;
      height: 90px;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='80' viewBox='0 0 24 80'%3E%3Cpath d='M12 0 C4 10 20 20 12 32 C4 44 20 54 12 64 C6 72 18 76 14 80' stroke='%238d97b5' stroke-width='2.4' fill='none' stroke-linecap='round'/%3E%3C/svg%3E");
      background-size: contain;
      background-repeat: no-repeat;
    }

    .carousel-content {
      flex: 1 1 auto;
      color: #2a3042;
    }

    .carousel-content h3 {
      margin: 0 0 0.5rem;
      font-size: 1.5rem;
    }

    .carousel-content p {
      margin: 0;
      color: #4c5469;
      line-height: 1.5;
    }

    .carousel-nav {
      border: none;
      background: rgba(83, 97, 132, 0.15);
      color: #2b3145;
      width: 42px;
      height: 42px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1.4rem;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s ease;
    }

    .carousel-nav:hover {
      background: rgba(83, 97, 132, 0.3);
    }

    .carousel-pagination {
      text-align: center;
      font-weight: 600;
      color: #5b6277;
    }

    .welcome-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: radial-gradient(circle at top, rgba(28, 38, 58, 0.95), rgba(5, 9, 18, 0.98));
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
      z-index: 900;
    }

    .welcome-card {
      background: #ffffff;
      border-radius: 32px;
      padding: clamp(1.5rem, 4vw, 3rem);
      max-width: 640px;
      text-align: center;
      box-shadow: 0 25px 55px rgba(10, 16, 34, 0.45);
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .welcome-card img {
      max-width: 260px;
      width: 70%;
      height: auto;
      align-self: center;
    }

    .welcome-card h2 {
      margin: 0;
      font-size: clamp(1.5rem, 3vw, 2.4rem);
      color: #212a3a;
    }

    .welcome-card p {
      margin: 0;
      color: #4a5166;
      line-height: 1.5;
    }

    .welcome-card .primary-btn {
      align-self: center;
      padding-inline: 2.25rem;
      font-size: 1.05rem;
    }

    body.modal-open,
    body.overlay-open {
      overflow: hidden;
    }

    @keyframes anchoredFloat {
      0% {
        transform: translate3d(0, 0, 0) scale(0.98);
      }
      50% {
        transform: translate3d(var(--ax1), var(--ay1), 0) scale(1);
      }
      100% {
        transform: translate3d(0, 0, 0) scale(0.98);
      }
    }

    @media (max-width: 640px) {
      .brand {
        position: static;
        margin-bottom: 0.5rem;
      }
      .floating-actions {
        position: static;
        align-self: flex-end;
      }
      .balloon {
        --balloon-scale: 0.82;
        font-size: 0.78rem;
      }
      .dropzone {
        min-height: 150px;
      }
      .carousel-slide {
        flex-direction: column;
        text-align: center;
      }
      .carousel-balloon {
        margin-bottom: 1rem;
      }
      .modal-dialog {
        padding: 1.5rem;
      }
    }

    @keyframes pop {
      from {
        transform: scale(0.9);
        opacity: 0;
      }
      to {
        transform: scale(1);
        opacity: 1;
      }
    }
  </style>
</head>
  <body>
    <div class="welcome-overlay" id="welcomeOverlay" aria-hidden="false">
      <div class="welcome-card">
        <img src="assets/SL_Full_B.png" alt="Stacked Learning logo" />
        <h2>Welcome to Stacked Learning Six Core Traits of World Business Leaders Identification Game</h2>
        <p>Drag the balloons around the sky and anchor only the six leadership qualities that define top global business leaders.</p>
        <button type="button" class="primary-btn" id="startGame">Start Exploring</button>
      </div>
    </div>
    <main>
      <div class="brand">
        <img src="assets/SL_Full_B.png" alt="Stacked Learning logo" />
      </div>
      <div class="floating-actions">
        <button type="button" class="ghost-btn" id="floatingRestart" aria-label="Restart the game">
          Restart
        </button>
        <button type="button" class="primary-btn" id="floatingTraits" aria-label="Meet the traits" hidden>
          Meet the Traits
        </button>
      </div>
      <h1>Identify the Six Core Traits of World Business Leaders</h1>
      <p class="subtitle">Drag the balloons to the anchor area to test your instincts.</p>

      <section class="field" id="balloonField"></section>

    <section class="anchor-area">
      <p class="anchor-status">Anchored: <span id="anchorCount">0</span> / <span id="anchorMax">6</span></p>
      <div class="dropzone" id="anchorZone" aria-label="Drop balloons here to anchor them">
        <label>Drop balloons here to anchor them</label>
        <div class="anchor-slot" id="anchorSlot"></div>
      </div>
    </section>

    <div class="completion-overlay" id="completionOverlay" aria-hidden="true">
      <div class="completion-card">
        <h2>Well done!</h2>
        <p>You anchored every essential leadership balloon.</p>
        <div class="completion-actions">
          <button type="button" class="ghost-btn" id="restartGame">Restart</button>
          <button type="button" class="primary-btn" id="openCarousel">Meet the Traits</button>
        </div>
      </div>
    </div>

    <div class="modal" id="carouselModal" aria-hidden="true">
      <div class="modal-dialog" role="dialog" aria-modal="true" aria-label="Leadership trait details">
        <button class="modal-close" id="closeCarousel" aria-label="Close dialog">&times;</button>
        <div class="carousel" id="carousel">
          <button type="button" class="carousel-nav prev" id="prevSlide" aria-label="Previous trait">&#10094;</button>
          <div class="carousel-viewport">
            <div class="carousel-track" id="carouselTrack"></div>
          </div>
          <button type="button" class="carousel-nav next" id="nextSlide" aria-label="Next trait">&#10095;</button>
        </div>
        <div class="carousel-pagination" id="carouselPagination"></div>
      </div>
    </div>
  </main>

  <script>
    /*
      Customize here:
      - Edit `balloonConfig` to change balloon labels/keywords/colors.
      - Edit `allowedKeywords` to control which balloon keywords may anchor.
      - Edit `maxAnchored` to adjust the total number of balloons that can anchor.
    */
    const balloonConfig = [
      { label: "Global mindset and cultural intelligence", keyword: "Global mindset and cultural intelligence", color: "#ff6f61" },
      { label: "Strategic vision and foresight", keyword: "Strategic vision and foresight", color: "#faae2b" },
      { label: "Resilience and adaptability", keyword: "Resilience and adaptability", color: "#ffd166" },
      { label: "Empathic and authentic communication", keyword: "Empathic and authentic communication", color: "#20c997" },
      { label: "Emotional intelligence (EQ)", keyword: "Emotional intelligence (EQ)", color: "#4ea8de" },
      { label: "Integrity and ethical leadership", keyword: "Integrity and ethical leadership", color: "#9775fa" },
      { label: "Accountability", keyword: "Accountability", color: "#ff5d8f" },
      { label: "Decisiveness", keyword: "Decisiveness", color: "#ff922b" },
      { label: "Creativity", keyword: "Creativity", color: "#f9c74f" },
      { label: "Charismatic", keyword: "Charismatic", color: "#f9844a" },
      { label: "Learning agility", keyword: "Learning agility", color: "#1dd3b0" },
      { label: "Humility", keyword: "Humility", color: "#74c69d" },
      { label: "Coaching mindset", keyword: "Coaching mindset", color: "#ef476f" },
      { label: "Conflict navigation", keyword: "Conflict navigation", color: "#f28482" },
      { label: "Stakeholder awareness", keyword: "Stakeholder awareness", color: "#ff7f51" },
      { label: "Operational discipline", keyword: "Operational discipline", color: "#90be6d" },
      { label: "Risk awareness", keyword: "Risk awareness", color: "#f3722c" },
      { label: "Resourcefulness", keyword: "Resourcefulness", color: "#ffb4a2" },
      { label: "Influence without authority", keyword: "Influence without authority", color: "#4dd4c6" },
      { label: "Collaboration mindset", keyword: "Collaboration mindset", color: "#4895ef" },
      { label: "Measured confidence", keyword: "Measured confidence", color: "#b5838d" },
      { label: "Practical judgement", keyword: "Practical judgement", color: "#ff9e5c" }
    ];
    const allowedKeywords = [
      "Global mindset and cultural intelligence",
      "Strategic vision and foresight",
      "Resilience and adaptability",
      "Empathic and authentic communication",
      "Emotional intelligence (EQ)",
      "Integrity and ethical leadership"
    ];
    const balloonProfiles = [
      {
        radius: "48% 52% 60% 40% / 34% 40% 66% 66%",
        widthRange: [120, 145],
        heightFactorRange: [1.25, 1.4]
      },
      {
        radius: "50%",
        widthRange: [110, 130],
        heightFactorRange: [1.02, 1.1]
      }
    ];
    const leadershipTraits = [
      {
        keyword: "Global mindset and cultural intelligence",
        intro:
          "This is the foundation of modern leadership. Effective leaders understand and respect diverse cultures, adapt communication styles across regions, and build trust in multicultural environments."
      },
      {
        keyword: "Strategic vision and foresight",
        intro:
          "Leaders must anticipate long-term global trends, technological shifts, and geopolitical dynamics. The most effective combine vision with agility, pivoting decisively when conditions change."
      },
      {
        keyword: "Resilience and adaptability",
        intro:
          "Emotional toughness and flexibility are core to global leadership. Great leaders maintain composure under pressure, recover quickly from setbacks, and remain steady through uncertainty."
      },
      {
        keyword: "Empathic and authentic communication",
        intro:
          "Leadership depends on the ability to connect meaningfully across languages, cultures, and levels of an organization. The focus is on clarity, empathy, and consistency between message and action."
      },
      {
        keyword: "Emotional intelligence (EQ)",
        intro:
          "Leaders with strong EQ manage their emotions and read others accurately. It drives collaboration, trust, and influence, especially in high-pressure or cross-functional settings."
      },
      {
        keyword: "Integrity and ethical leadership",
        intro:
          "Integrity, transparency, and moral courage are critical to credibility and sustainability, especially in complex global markets."
      }
    ];
    const maxAnchored = 6;
    const totalBalloons = balloonConfig.length;

    const balloonField = document.getElementById("balloonField");
    const anchorZone = document.getElementById("anchorZone");
    const anchorSlot = document.getElementById("anchorSlot");
    const anchorCountEl = document.getElementById("anchorCount");
    const anchorMaxEl = document.getElementById("anchorMax");
    const completionOverlay = document.getElementById("completionOverlay");
    const restartButton = document.getElementById("restartGame");
    const openCarouselButton = document.getElementById("openCarousel");
    const carouselModal = document.getElementById("carouselModal");
    const closeCarouselButton = document.getElementById("closeCarousel");
    const carouselTrack = document.getElementById("carouselTrack");
    const carouselPagination = document.getElementById("carouselPagination");
    const prevSlideButton = document.getElementById("prevSlide");
    const nextSlideButton = document.getElementById("nextSlide");
    const carouselViewport = document.querySelector(".carousel-viewport");
    const floatingRestartButton = document.getElementById("floatingRestart");
    const floatingTraitsButton = document.getElementById("floatingTraits");
    const welcomeOverlay = document.getElementById("welcomeOverlay");
    const startGameButton = document.getElementById("startGame");

    anchorMaxEl.textContent = maxAnchored;

    const anchoredBalloons = [];
    const initialPlacements = [];
    let activeBalloon = null;
    let pointerId = null;
    let startOffset = { x: 0, y: 0 };
    let dragStart = { left: 0, top: 0 };
    let fieldRect = null;
    let dragAreaHeight = 0;
    let zIndexSeed = 80;
    let hasCelebrated = false;
    let currentSlide = 0;
    let carouselItems = leadershipTraits;
    const colorLookup = balloonConfig.reduce((acc, item) => {
      if (!acc[item.keyword]) {
        acc[item.keyword] = item.color;
      }
      return acc;
    }, {});

    const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
    const toTitleCase = (text) =>
      text.replace(/\w\S*/g, (word) => {
        if (word.length > 1 && word === word.toUpperCase()) {
          return word;
        }
        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
      });
    const floaters = new Map();
    const randomBetween = (min, max) => min + Math.random() * (max - min);

    const updateAnchorStatus = () => {
      anchorCountEl.textContent = anchoredBalloons.length;
      anchorZone.classList.toggle("full", anchoredBalloons.length >= maxAnchored);
    };

    const rectanglesOverlap = (a, b, gap = 12) => {
      const expandedA = {
        left: a.left - gap,
        right: a.left + a.width + gap,
        top: a.top - gap,
        bottom: a.top + a.height + gap
      };
      const expandedB = {
        left: b.left - gap,
        right: b.left + b.width + gap,
        top: b.top - gap,
        bottom: b.top + b.height + gap
      };

      return !(
        expandedA.right < expandedB.left ||
        expandedA.left > expandedB.right ||
        expandedA.bottom < expandedB.top ||
        expandedA.top > expandedB.bottom
      );
    };

    const randomizePosition = (el) => {
      const rect = balloonField.getBoundingClientRect();
      const index = initialPlacements.length;
      const cols = Math.max(3, Math.ceil(Math.sqrt(totalBalloons)));
      const rows = Math.ceil(totalBalloons / cols);
      const cellW = rect.width / cols;
      const cellH = rect.height / rows;

      const col = index % cols;
      const row = Math.floor(index / cols);

      const jitterX = randomBetween(-cellW * 0.3, cellW * 0.3);
      const jitterY = randomBetween(-cellH * 0.3, cellH * 0.3);

      let left =
        col * cellW + (cellW - el.offsetWidth) / 2 + jitterX;
      let top =
        row * cellH + (cellH - el.offsetHeight) / 2 + jitterY;

      left = clamp(left, 0, Math.max(rect.width - el.offsetWidth, 0));
      top = clamp(top, 0, Math.max(rect.height - el.offsetHeight, 0));

      const candidate = {
        left,
        top,
        width: el.offsetWidth,
        height: el.offsetHeight
      };

      initialPlacements.push(candidate);
      el.style.left = `${candidate.left}px`;
      el.style.top = `${candidate.top}px`;
    };

    const setupFloater = (el) => {
      floaters.set(el, {
        vx: randomBetween(-0.35, 0.35),
        vy: randomBetween(-0.55, -0.15)
      });
    };

    const updateFloaters = () => {
      const rect = balloonField.getBoundingClientRect();
      floaters.forEach((vel, el) => {
        if (el.dataset.anchored === "true" || el.dataset.dragging === "true") return;

        let left = parseFloat(el.style.left) || 0;
        let top = parseFloat(el.style.top) || 0;

        left += vel.vx;
        top += vel.vy;

        const maxLeft = Math.max(0, rect.width - el.offsetWidth);
        const maxTop = Math.max(0, rect.height - el.offsetHeight);
        let bounced = false;

        if (left < 0) {
          left = 0;
          vel.vx = Math.abs(vel.vx);
          bounced = true;
        } else if (left > maxLeft) {
          left = maxLeft;
          vel.vx = -Math.abs(vel.vx);
          bounced = true;
        }

        if (top < 0) {
          top = 0;
          vel.vy = Math.abs(vel.vy);
          bounced = true;
        } else if (top > maxTop) {
          top = maxTop;
          vel.vy = -Math.abs(vel.vy);
          bounced = true;
        }

        if (Math.random() < 0.02 || bounced) {
          vel.vx = clamp(vel.vx + randomBetween(-0.1, 0.1), -0.45, 0.45);
          vel.vy = clamp(vel.vy + randomBetween(-0.1, 0.1), -0.65, 0.1);
        }

        el.style.left = `${left}px`;
        el.style.top = `${top}px`;
      });

      requestAnimationFrame(updateFloaters);
    };

    const isOverAnchorZone = (element) => {
      const balloonRect = element.getBoundingClientRect();
      const anchorRect = anchorZone.getBoundingClientRect();

      return !(
        balloonRect.right < anchorRect.left ||
        balloonRect.left > anchorRect.right ||
        balloonRect.bottom < anchorRect.top ||
        balloonRect.top > anchorRect.bottom
      );
    };

    const anchorBalloon = (balloon) => {
      if (anchoredBalloons.includes(balloon)) return;
      const startRect = balloon.getBoundingClientRect();
      anchoredBalloons.push(balloon);
      balloon.classList.add("anchored");
      balloon.classList.add("anchoring");
      balloon.dataset.anchored = "true";
      balloon.style.left = "";
      balloon.style.top = "";
      balloon.style.zIndex = "";
      anchorSlot.appendChild(balloon);

      const endRect = balloon.getBoundingClientRect();
      const deltaX = startRect.left - endRect.left;
      const deltaY = startRect.top - endRect.top;

      balloon.style.transition = "none";
      balloon.style.transform = `translate(${deltaX}px, ${deltaY}px)`;

      // Force reflow
      balloon.getBoundingClientRect();

      requestAnimationFrame(() => {
        balloon.style.transition = "transform 0.35s ease";
        balloon.style.transform = "translate(0, 0)";
      });

      const clearAnimation = () => {
        balloon.style.transition = "";
        balloon.style.transform = "";
        balloon.classList.remove("anchoring");
        balloon.removeEventListener("transitionend", clearAnimation);
      };
      balloon.addEventListener("transitionend", clearAnimation);

      balloon.addEventListener("click", () => openTraitDetail(balloon.dataset.keyword));
      updateAnchorStatus();
      checkCompletionState();
    };

    const pointerDown = (event) => {
      const balloon = event.currentTarget;
      if (balloon.dataset.anchored === "true") return;

      event.preventDefault();
      activeBalloon = balloon;
      pointerId = event.pointerId;
      balloon.dataset.dragging = "true";
      fieldRect = balloonField.getBoundingClientRect();
      const anchorRect = anchorZone.getBoundingClientRect();
      const totalHeight = anchorRect.bottom - fieldRect.top;
      dragAreaHeight = Math.max(fieldRect.height, totalHeight);

      const rect = balloon.getBoundingClientRect();
      startOffset = { x: event.clientX - rect.left, y: event.clientY - rect.top };
      dragStart = {
        left: parseFloat(balloon.style.left) || 0,
        top: parseFloat(balloon.style.top) || 0
      };

      balloon.style.transition = "none";
      balloon.classList.add("dragging");
      balloon.style.zIndex = ++zIndexSeed;

      balloon.setPointerCapture(pointerId);
      balloon.addEventListener("pointermove", pointerMove);
      balloon.addEventListener("pointerup", pointerUp);
      balloon.addEventListener("pointercancel", pointerUp);
    };

    const pointerMove = (event) => {
      if (!activeBalloon || event.pointerId !== pointerId) return;

      const maxLeft = Math.max(0, fieldRect.width - activeBalloon.offsetWidth);
      const maxTop = Math.max(0, dragAreaHeight - activeBalloon.offsetHeight);

      let newLeft = event.clientX - fieldRect.left - startOffset.x;
      let newTop = event.clientY - fieldRect.top - startOffset.y;

      newLeft = clamp(newLeft, 0, maxLeft);
      newTop = clamp(newTop, 0, maxTop);

      activeBalloon.style.left = `${newLeft}px`;
      activeBalloon.style.top = `${newTop}px`;

      const ready =
        allowedKeywords.includes(activeBalloon.dataset.keyword) &&
        anchoredBalloons.length < maxAnchored &&
        isOverAnchorZone(activeBalloon);

      anchorZone.classList.toggle("ready", ready);
    };

    const pointerUp = (event) => {
      if (!activeBalloon || event.pointerId !== pointerId) return;

      const balloon = activeBalloon;
      balloon.releasePointerCapture(pointerId);
      balloon.removeEventListener("pointermove", pointerMove);
      balloon.removeEventListener("pointerup", pointerUp);
      balloon.removeEventListener("pointercancel", pointerUp);

      balloon.classList.remove("dragging");
      balloon.style.transition = "";
      anchorZone.classList.remove("ready");

      const droppedInAnchor = isOverAnchorZone(balloon);
      const validDrop =
        allowedKeywords.includes(balloon.dataset.keyword) &&
        anchoredBalloons.length < maxAnchored &&
        droppedInAnchor;

      if (validDrop) {
        anchorBalloon(balloon);
      } else {
        if (droppedInAnchor) {
          balloon.style.left = `${dragStart.left}px`;
          balloon.style.top = `${dragStart.top}px`;
        }
        balloon.style.zIndex = "";
      }

      balloon.dataset.dragging = "false";
      activeBalloon = null;
      pointerId = null;
    };

    const renderCarousel = (filterKeyword = null) => {
      carouselTrack.innerHTML = "";
      carouselItems = filterKeyword
        ? leadershipTraits.filter(
            (trait) => trait.keyword.toLowerCase() === filterKeyword.toLowerCase()
          )
        : leadershipTraits;

      carouselItems.forEach((trait) => {
        const slide = document.createElement("div");
        slide.className = "carousel-slide";

        const balloon = document.createElement("div");
        balloon.className = "carousel-balloon";
        balloon.style.setProperty("--fill", colorLookup[trait.keyword] || "#ff8f87");
        balloon.textContent = trait.keyword.split(" ")[0] || trait.keyword;

        const content = document.createElement("div");
        content.className = "carousel-content";
        const heading = document.createElement("h3");
        heading.textContent = trait.keyword;
        const copy = document.createElement("p");
        copy.textContent = trait.intro;

        content.appendChild(heading);
        content.appendChild(copy);

        slide.appendChild(balloon);
        slide.appendChild(content);
        carouselTrack.appendChild(slide);
      });
      const showNavigation = !filterKeyword && carouselItems.length > 1;
      prevSlideButton.style.display = showNavigation ? "flex" : "none";
      nextSlideButton.style.display = showNavigation ? "flex" : "none";
      carouselPagination.style.display = filterKeyword ? "none" : "block";
      currentSlide = 0;
      updateCarousel();
    };

    const updateCarousel = () => {
      const total = carouselItems.length || 1;
      currentSlide = (currentSlide + total) % total;
      carouselTrack.style.transform = `translateX(-${currentSlide * 100}%)`;
      if (carouselPagination.style.display !== "none") {
        carouselPagination.textContent = `${currentSlide + 1} / ${total}`;
      }
    };

    const goToSlide = (index) => {
      const total = carouselItems.length || 1;
      currentSlide = (index + total) % total;
      updateCarousel();
    };

    const nextSlide = () => goToSlide(currentSlide + 1);
    const prevSlide = () => goToSlide(currentSlide - 1);

    const openTraitDetail = (keyword) => {
      openCarouselModal(keyword);
    };

    const showCompletionOverlay = () => {
      completionOverlay.classList.add("active");
      completionOverlay.setAttribute("aria-hidden", "false");
      document.body.classList.add("overlay-open");
    };

    const hideCompletionOverlay = () => {
      if (!completionOverlay.classList.contains("active")) return;
      completionOverlay.classList.remove("active");
      completionOverlay.setAttribute("aria-hidden", "true");
      document.body.classList.remove("overlay-open");
    };

    const openCarouselModal = (filterKeyword = null) => {
      renderCarousel(filterKeyword);
      carouselModal.classList.add("active");
      carouselModal.setAttribute("aria-hidden", "false");
      document.body.classList.add("modal-open");
    };

    const closeCarouselModal = () => {
      carouselModal.classList.remove("active");
      carouselModal.setAttribute("aria-hidden", "true");
      document.body.classList.remove("modal-open");
    };

    const checkCompletionState = () => {
      if (!hasCelebrated && anchoredBalloons.length >= maxAnchored) {
        hasCelebrated = true;
        floatingTraitsButton.hidden = false;
        showCompletionOverlay();
      }
    };

    const hideWelcomeOverlay = () => {
      if (!welcomeOverlay) return;
      welcomeOverlay.style.display = "none";
      welcomeOverlay.setAttribute("aria-hidden", "true");
      document.body.classList.remove("overlay-open");
    };

    const showWelcomeOverlay = () => {
      if (!welcomeOverlay) return;
      welcomeOverlay.style.display = "flex";
      welcomeOverlay.setAttribute("aria-hidden", "false");
      document.body.classList.add("overlay-open");
    };

    const handleRestart = () => {
      window.location.reload();
    };

    const handleCarouselOpen = () => {
      if (completionOverlay.classList.contains("active")) {
        hideCompletionOverlay();
      }
      openCarouselModal();
    };

    const handleOverlayClick = (event) => {
      if (event.target === completionOverlay) {
        hideCompletionOverlay();
      }
    };

    const handleModalClick = (event) => {
      if (event.target === carouselModal) {
        closeCarouselModal();
      }
    };

    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        if (carouselModal.classList.contains("active")) {
          closeCarouselModal();
        } else if (completionOverlay.classList.contains("active")) {
          hideCompletionOverlay();
        } else if (welcomeOverlay && welcomeOverlay.style.display !== "none") {
          hideWelcomeOverlay();
        }
      }
    };

    const enableCarouselSwipe = () => {
      let isPointerDown = false;
      let startX = 0;

      const onPointerDown = (event) => {
        isPointerDown = true;
        startX = event.clientX;
      };

      const onPointerUp = (event) => {
        if (!isPointerDown) return;
        const deltaX = event.clientX - startX;
        if (Math.abs(deltaX) > 40) {
          deltaX < 0 ? nextSlide() : prevSlide();
        }
        isPointerDown = false;
      };

      const cancelSwipe = () => {
        isPointerDown = false;
      };

      carouselViewport.addEventListener("pointerdown", onPointerDown);
      carouselViewport.addEventListener("pointerup", onPointerUp);
      carouselViewport.addEventListener("pointerleave", cancelSwipe);
      carouselViewport.addEventListener("pointercancel", cancelSwipe);
    };

    const createBalloon = (data) => {
      const el = document.createElement("div");
      el.className = "balloon";
      el.dataset.keyword = data.keyword;
      el.setAttribute("aria-label", `Balloon ${data.label}`);
      el.style.setProperty("--fill", data.color);
      if (allowedKeywords.includes(data.keyword)) {
        el.classList.add("allowed");
      }

      const profile = balloonProfiles[Math.floor(Math.random() * balloonProfiles.length)];
      const randomWidth =
        profile.widthRange[0] + Math.random() * (profile.widthRange[1] - profile.widthRange[0]);
      const textBoost = Math.min(90, Math.max(0, data.label.length - 18) * 1.5);
      let finalWidth = Math.min(260, Math.max(randomWidth, 135 + textBoost));
      if (data.keyword === "Resourcefulness") {
        finalWidth = Math.max(finalWidth, 250);
      }
      const heightFactor =
        profile.heightFactorRange[0] +
        Math.random() * (profile.heightFactorRange[1] - profile.heightFactorRange[0]);
      let finalHeight = finalWidth * heightFactor;
      if (data.keyword === "Resourcefulness") {
        // Make Resourcefulness a wider, lower oval and slightly smaller overall
        finalWidth = Math.max(finalWidth * 0.95, 225);
        finalHeight = Math.min(finalHeight * 0.78, finalWidth * 0.78);
        el.style.setProperty("--balloon-radius", "55% 45% 50% 50% / 60% 60% 45% 45%");
      }

      el.style.setProperty("--balloon-width", `${finalWidth}px`);
      el.style.setProperty("--balloon-height", `${finalHeight}px`);
      el.style.setProperty("--balloon-radius", profile.radius);

      const duration = (10 + Math.random() * 4).toFixed(2);
      const delay = (Math.random() * 2.5).toFixed(2);

      const randomOffset = (max) => {
        const magnitude = max * (0.5 + Math.random() * 0.5); // 50-100% of max
        return `${(Math.random() < 0.5 ? -1 : 1) * magnitude.toFixed(1)}px`;
      };

      el.style.setProperty("--fx1", randomOffset(45));
      el.style.setProperty("--fy1", randomOffset(55));
      el.style.setProperty("--fx2", randomOffset(60));
      el.style.setProperty("--fy2", randomOffset(70));
      el.style.setProperty("--fx3", randomOffset(55));
      el.style.setProperty("--fy3", randomOffset(60));

      // Anchored drift (smaller magnitude)
      el.style.setProperty("--ax1", randomOffset(18));
      el.style.setProperty("--ay1", randomOffset(22));
      el.style.setProperty("--float-duration", `${duration}s`);
      el.style.setProperty("--float-delay", `${delay}s`);

      const label = document.createElement("span");
      label.className = "balloon-label";
      label.textContent = toTitleCase(data.label);

      el.appendChild(label);

      balloonField.appendChild(el);
      randomizePosition(el);
      setupFloater(el);
      el.addEventListener("pointerdown", pointerDown);
    };

    // Init
    balloonConfig.forEach(createBalloon);
    updateAnchorStatus();
    renderCarousel();
    enableCarouselSwipe();
    updateFloaters();
    showWelcomeOverlay();

    restartButton.addEventListener("click", handleRestart);
    floatingRestartButton.addEventListener("click", handleRestart);
    openCarouselButton.addEventListener("click", handleCarouselOpen);
    floatingTraitsButton.addEventListener("click", handleCarouselOpen);
    startGameButton.addEventListener("click", hideWelcomeOverlay);
    completionOverlay.addEventListener("click", handleOverlayClick);
    prevSlideButton.addEventListener("click", prevSlide);
    nextSlideButton.addEventListener("click", nextSlide);
    closeCarouselButton.addEventListener("click", closeCarouselModal);
    carouselModal.addEventListener("click", handleModalClick);
    document.addEventListener("keydown", handleKeyDown);
  </script>
</body>
</html>
