<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Balloon Anchor Playground</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      height: 100vh;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      background: radial-gradient(circle at top, #f8fbff 0%, #e8edf5 55%, #dee3ee 100%);
      color: #2a2f3e;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      overflow: hidden;
    }

    main {
      flex: 1 1 auto;
      width: 100%;
      height: 100vh;
      min-height: 100vh;
      padding: clamp(1rem, 3vw, 2.5rem);
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      position: relative;
    }

    h1 {
      margin: 0;
      text-align: center;
      font-size: clamp(1.5rem, 4vw, 2.5rem);
      letter-spacing: 0.04em;
      color: #26324d;
    }

    .subtitle {
      text-align: center;
      margin: 0;
      font-size: 1rem;
      color: #4a5062;
    }

    .field {
      flex: 1 1 auto;
      width: 100%;
      min-height: 0;
      position: relative;
      z-index: 2;
      overflow: visible;
      border-radius: 28px;
      background: linear-gradient(145deg, #f4f7fc 0%, #dfe6f3 100%);
      border: 2px solid rgba(70, 92, 124, 0.15);
      box-shadow: 0 25px 45px rgba(35, 47, 73, 0.12);
    }

    .balloon {
      --fill: #ff9aa2;
      --balloon-scale: 1;
      position: absolute;
      width: calc(var(--balloon-width, 125px) * var(--balloon-scale));
      height: calc(var(--balloon-height, 130px) * var(--balloon-scale));
      border-radius: var(--balloon-radius, 48% 52% 55% 45% / 40% 42% 58% 60%);
      background:
        radial-gradient(circle at 30% 25%, rgba(255, 255, 255, 0.35), rgba(255, 255, 255, 0) 55%),
        linear-gradient(145deg, rgba(255, 255, 255, 0.08), rgba(0, 0, 0, 0.1)),
        var(--fill);
      color: #fff;
      font-weight: 600;
      font-size: 0.92rem;
      line-height: 1.3;
      text-align: center;
      padding: 0.85rem;
      display: flex;
      align-items: center;
      justify-content: center;
      word-break: break-word;
      white-space: normal;
      box-shadow: 0 14px 24px rgba(37, 49, 74, 0.25);
      cursor: grab;
      user-select: none;
      touch-action: none;
      transition: left 0.25s ease, top 0.25s ease, transform 0.2s ease, box-shadow 0.2s ease;
      animation: float var(--float-duration, 6s) ease-in-out infinite;
      animation-delay: var(--float-delay, 0s);
      animation-play-state: running;
      overflow: visible;
    }

    .balloon::before {
      content: "";
      position: absolute;
      width: 18px;
      height: 16px;
      bottom: -6px;
      left: 50%;
      transform: translateX(-50%) rotate(6deg);
      background: var(--fill);
      border-radius: 40% 40% 65% 65%;
      box-shadow: inset 0 -2px 4px rgba(0, 0, 0, 0.1);
      pointer-events: none;
    }

    .balloon::after {
      content: "";
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: -80px;
      width: 26px;
      height: 90px;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='80' viewBox='0 0 24 80'%3E%3Cpath d='M12 0 C4 10 20 20 12 32 C4 44 20 54 12 64 C6 72 18 76 14 80' stroke='%23a0a8c2' stroke-width='2.4' fill='none' stroke-linecap='round'/%3E%3C/svg%3E");
      background-size: contain;
      background-repeat: no-repeat;
      pointer-events: none;
    }

    .balloon.dragging {
      cursor: grabbing;
      transform: scale(1.08);
      animation-play-state: paused;
      box-shadow: 0 20px 34px rgba(24, 32, 51, 0.35);
    }

    .balloon.anchored {
      position: relative;
      width: calc(var(--balloon-width, 125px) * var(--balloon-scale) * 0.82);
      height: calc(var(--balloon-height, 130px) * var(--balloon-scale) * 0.82);
      border-radius: var(--balloon-radius, 48% 52% 55% 45% / 40% 42% 58% 60%);
      cursor: default;
      pointer-events: none;
      animation: none;
      animation-play-state: paused;
    }

    .balloon.anchored::before {
      bottom: -4px;
      width: 14px;
      height: 12px;
    }

    .balloon.anchored::after {
      bottom: -60px;
      height: 70px;
    }

    .balloon-label {
      position: relative;
      z-index: 1;
    }

    .anchor-area {
      flex: 0 0 auto;
      padding-bottom: 1rem;
      position: relative;
      z-index: 1;
    }

    .anchor-status {
      margin: 0;
      text-align: center;
      font-weight: 600;
      color: #4c536b;
      letter-spacing: 0.05em;
    }

    .dropzone {
      margin-top: 0.65rem;
      border-radius: 20px;
      border: 2px dashed rgba(57, 73, 100, 0.4);
      background: rgba(255, 255, 255, 0.8);
      padding: 1.2rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      transition: border-color 0.2s ease, background 0.2s ease;
      min-height: 170px;
      overflow: visible;
    }

    .dropzone.ready {
      border-color: #2eb086;
      background: rgba(206, 244, 225, 0.8);
    }

    .dropzone.full {
      border-color: #ea4c4c;
    }

    .dropzone label {
      font-size: 0.9rem;
      font-weight: 600;
      color: #515562;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .anchor-slot {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      min-height: 90px;
      align-items: center;
      overflow: visible;
    }

    .floating-actions {
      position: absolute;
      top: clamp(0.75rem, 2vw, 1.25rem);
      right: clamp(0.75rem, 2vw, 1.5rem);
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      justify-content: flex-end;
      z-index: 60;
    }

    .floating-actions .ghost-btn,
    .floating-actions .primary-btn {
      padding: 0.45rem 1.1rem;
      font-size: 0.9rem;
    }

    .floating-actions button[hidden] {
      display: none;
    }

    .brand {
      position: absolute;
      top: clamp(0.75rem, 2vw, 1.25rem);
      left: clamp(0.75rem, 2vw, 1.5rem);
      z-index: 70;
    }

    .brand img {
      height: clamp(40px, 12vw, 70px);
      width: auto;
      display: block;
    }


    .completion-overlay {
      position: fixed;
      inset: 0;
      background: rgba(14, 23, 38, 0.5);
      backdrop-filter: blur(6px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 200;
      padding: 1rem;
    }

    .completion-overlay.active {
      display: flex;
    }

    .completion-card {
      background: #fff;
      border-radius: 24px;
      padding: 2rem;
      max-width: 420px;
      text-align: center;
      box-shadow: 0 20px 45px rgba(20, 30, 55, 0.35);
      animation: pop 0.3s ease;
    }

    .completion-card h2 {
      margin: 0 0 0.5rem;
      font-size: 1.8rem;
      color: #25304a;
    }

    .completion-card p {
      margin: 0 0 1.5rem;
      color: #4e5568;
      font-size: 1rem;
    }

    .completion-actions {
      display: flex;
      gap: 0.75rem;
      justify-content: center;
      flex-wrap: wrap;
    }

    .primary-btn,
    .ghost-btn {
      border: none;
      border-radius: 14px;
      padding: 0.7rem 1.4rem;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .primary-btn {
      background: linear-gradient(135deg, #5d8bf4, #4fd1c5);
      color: #fff;
      box-shadow: 0 10px 20px rgba(74, 133, 236, 0.35);
    }

    .ghost-btn {
      background: #f5f7ff;
      color: #42506d;
      border: 1px solid rgba(66, 80, 109, 0.2);
    }

    .primary-btn:active,
    .ghost-btn:active {
      transform: translateY(1px);
    }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(12, 17, 29, 0.55);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      z-index: 250;
    }

    .modal.active {
      display: flex;
    }

    .modal-dialog {
      background: #ffffff;
      border-radius: 32px;
      width: min(1100px, 95vw);
      max-height: 92vh;
      padding: 2.5rem 3rem;
      box-shadow: 0 25px 50px rgba(20, 30, 55, 0.4);
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .modal-close {
      position: absolute;
      top: 1rem;
      right: 1.5rem;
      border: none;
      background: none;
      font-size: 2rem;
      cursor: pointer;
      color: #8b94ac;
    }

    .carousel {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .carousel-viewport {
      overflow: hidden;
      flex: 1 1 auto;
    }

    .carousel-track {
      display: flex;
      transition: transform 0.4s ease;
      touch-action: pan-y;
    }

    .carousel-slide {
      width: 100%;
      display: flex;
      gap: 1.5rem;
      align-items: center;
      flex-shrink: 0;
    }

    .carousel-balloon {
      width: 220px;
      aspect-ratio: 3 / 4;
      border-radius: 48% 52% 60% 40% / 34% 40% 66% 66%;
      background: var(--fill, #ff8f87);
      background-image:
        radial-gradient(circle at 30% 25%, rgba(255, 255, 255, 0.35), rgba(255, 255, 255, 0) 60%),
        linear-gradient(145deg, rgba(255, 255, 255, 0.08), rgba(0, 0, 0, 0.1));
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-weight: 700;
      font-size: 1.2rem;
      text-align: center;
      padding: 1rem;
    }

    .carousel-balloon::before {
      content: "";
      position: absolute;
      bottom: -14px;
      left: 50%;
      transform: translateX(-50%) rotate(8deg);
      width: 28px;
      height: 20px;
      background: var(--fill, #ff8f87);
      border-radius: 45% 45% 70% 70%;
      box-shadow: inset 0 -2px 4px rgba(0, 0, 0, 0.12);
    }

    .carousel-balloon::after {
      content: "";
      position: absolute;
      bottom: -80px;
      left: 50%;
      transform: translateX(-50%);
      width: 28px;
      height: 90px;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='80' viewBox='0 0 24 80'%3E%3Cpath d='M12 0 C4 10 20 20 12 32 C4 44 20 54 12 64 C6 72 18 76 14 80' stroke='%238d97b5' stroke-width='2.4' fill='none' stroke-linecap='round'/%3E%3C/svg%3E");
      background-size: contain;
      background-repeat: no-repeat;
    }

    .carousel-content {
      flex: 1 1 auto;
      color: #2a3042;
    }

    .carousel-content h3 {
      margin: 0 0 0.5rem;
      font-size: 1.5rem;
    }

    .carousel-content p {
      margin: 0;
      color: #4c5469;
      line-height: 1.5;
    }

    .carousel-nav {
      border: none;
      background: rgba(83, 97, 132, 0.15);
      color: #2b3145;
      width: 42px;
      height: 42px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1.4rem;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s ease;
    }

    .carousel-nav:hover {
      background: rgba(83, 97, 132, 0.3);
    }

    .carousel-pagination {
      text-align: center;
      font-weight: 600;
      color: #5b6277;
    }

    .welcome-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: radial-gradient(circle at top, rgba(28, 38, 58, 0.95), rgba(5, 9, 18, 0.98));
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
      z-index: 900;
    }

    .welcome-card {
      background: #ffffff;
      border-radius: 32px;
      padding: clamp(1.5rem, 4vw, 3rem);
      max-width: 640px;
      text-align: center;
      box-shadow: 0 25px 55px rgba(10, 16, 34, 0.45);
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .welcome-card img {
      max-width: 260px;
      width: 70%;
      height: auto;
      align-self: center;
    }

    .welcome-card h2 {
      margin: 0;
      font-size: clamp(1.5rem, 3vw, 2.4rem);
      color: #212a3a;
    }

    .welcome-card p {
      margin: 0;
      color: #4a5166;
      line-height: 1.5;
    }

    .welcome-card .primary-btn {
      align-self: center;
      padding-inline: 2.25rem;
      font-size: 1.05rem;
    }

    body.modal-open,
    body.overlay-open {
      overflow: hidden;
    }

    @keyframes float {
      0% {
        transform: translate3d(0, 0, 0);
      }
      50% {
        transform: translate3d(4px, -14px, 0);
      }
      100% {
        transform: translate3d(0, 0, 0);
      }
    }

    @media (max-width: 640px) {
      .brand {
        position: static;
        margin-bottom: 0.5rem;
      }
      .floating-actions {
        position: static;
        align-self: flex-end;
      }
      .balloon {
        --balloon-scale: 0.82;
        font-size: 0.78rem;
      }
      .dropzone {
        min-height: 150px;
      }
      .carousel-slide {
        flex-direction: column;
        text-align: center;
      }
      .carousel-balloon {
        margin-bottom: 1rem;
      }
      .modal-dialog {
        padding: 1.5rem;
      }
    }

    @keyframes pop {
      from {
        transform: scale(0.9);
        opacity: 0;
      }
      to {
        transform: scale(1);
        opacity: 1;
      }
    }
  </style>
</head>
  <body>
    <div class="welcome-overlay" id="welcomeOverlay" aria-hidden="false">
      <div class="welcome-card">
        <img src="assets/SL_Full_B.png" alt="Stacked Learning logo" />
        <h2>Welcome to Stacked Learning Six Core Traits of World Business Leaders Identification Game</h2>
        <p>Drag the balloons around the sky and anchor only the six leadership qualities that define top global business leaders.</p>
        <button type="button" class="primary-btn" id="startGame">Start Exploring</button>
      </div>
    </div>
    <main>
      <div class="brand">
        <img src="assets/SL_Full_B.png" alt="Stacked Learning logo" />
      </div>
      <div class="floating-actions">
        <button type="button" class="ghost-btn" id="floatingRestart" aria-label="Restart the game">
          Restart
        </button>
        <button type="button" class="primary-btn" id="floatingTraits" aria-label="Meet the traits" hidden>
          Meet the Traits
        </button>
      </div>
      <h1>Identify the Six Core Traits of World Business Leaders</h1>
      <p class="subtitle">Drag the balloons to the anchor area to test your instincts.</p>

      <section class="field" id="balloonField"></section>

    <section class="anchor-area">
      <p class="anchor-status">Anchored: <span id="anchorCount">0</span> / <span id="anchorMax">6</span></p>
      <div class="dropzone" id="anchorZone" aria-label="Drop balloons here to anchor them">
        <label>Drop balloons here to anchor them</label>
        <div class="anchor-slot" id="anchorSlot"></div>
      </div>
    </section>

    <div class="completion-overlay" id="completionOverlay" aria-hidden="true">
      <div class="completion-card">
        <h2>Well done!</h2>
        <p>You anchored every essential leadership balloon.</p>
        <div class="completion-actions">
          <button type="button" class="ghost-btn" id="restartGame">Restart</button>
          <button type="button" class="primary-btn" id="openCarousel">Meet the Traits</button>
        </div>
      </div>
    </div>

    <div class="modal" id="carouselModal" aria-hidden="true">
      <div class="modal-dialog" role="dialog" aria-modal="true" aria-label="Leadership trait details">
        <button class="modal-close" id="closeCarousel" aria-label="Close dialog">&times;</button>
        <div class="carousel" id="carousel">
          <button type="button" class="carousel-nav prev" id="prevSlide" aria-label="Previous trait">&#10094;</button>
          <div class="carousel-viewport">
            <div class="carousel-track" id="carouselTrack"></div>
          </div>
          <button type="button" class="carousel-nav next" id="nextSlide" aria-label="Next trait">&#10095;</button>
        </div>
        <div class="carousel-pagination" id="carouselPagination"></div>
      </div>
    </div>
  </main>

  <script>
    /*
      Customize here:
      - Edit `balloonConfig` to change balloon labels/keywords/colors.
      - Edit `allowedKeywords` to control which balloon keywords may anchor.
      - Edit `maxAnchored` to adjust the total number of balloons that can anchor.
    */
    const balloonConfig = [
      { label: "Global mindset and cultural intelligence", keyword: "Global mindset and cultural intelligence", color: "#ff8f87" },
      { label: "Strategic vision and foresight", keyword: "Strategic vision and foresight", color: "#ffa654" },
      { label: "Resilience and adaptability", keyword: "Resilience and adaptability", color: "#ffd35d" },
      { label: "Empathic and authentic communication", keyword: "Empathic and authentic communication", color: "#4ecdc4" },
      { label: "Emotional intelligence (EQ)", keyword: "Emotional intelligence (EQ)", color: "#6fb8ff" },
      { label: "Integrity and ethical leadership", keyword: "Integrity and ethical leadership", color: "#c29bff" },
      { label: "Accountability", keyword: "Accountability", color: "#ff9fb6" },
      { label: "Decisiveness", keyword: "Decisiveness", color: "#ffb284" },
      { label: "Creativity", keyword: "Creativity", color: "#ffc75f" },
      { label: "Charismatic", keyword: "Charismatic", color: "#fbc687" },
      { label: "Learning agility", keyword: "Learning agility", color: "#7dd8c2" },
      { label: "Humility", keyword: "Humility", color: "#9dd4ff" },
      { label: "Coaching mindset", keyword: "Coaching mindset", color: "#f58ad0" },
      { label: "Conflict navigation", keyword: "Conflict navigation", color: "#f9a1bc" },
      { label: "Stakeholder awareness", keyword: "Stakeholder awareness", color: "#ffb07f" },
      { label: "Operational discipline", keyword: "Operational discipline", color: "#ff9d76" },
      { label: "Risk awareness", keyword: "Risk awareness", color: "#f08a5d" },
      { label: "Resourcefulness", keyword: "Resourcefulness", color: "#ffbb91" },
      { label: "Influence without authority", keyword: "Influence without authority", color: "#72d6c9" },
      { label: "Collaboration mindset", keyword: "Collaboration mindset", color: "#8fd3fe" },
      { label: "Measured confidence", keyword: "Measured confidence", color: "#c6a4ff" },
      { label: "Practical judgement", keyword: "Practical judgement", color: "#f1a17b" }
    ];
    const allowedKeywords = [
      "Global mindset and cultural intelligence",
      "Strategic vision and foresight",
      "Resilience and adaptability",
      "Empathic and authentic communication",
      "Emotional intelligence (EQ)",
      "Integrity and ethical leadership"
    ];
    const balloonProfiles = [
      {
        radius: "48% 52% 60% 40% / 34% 40% 66% 66%",
        widthRange: [120, 145],
        heightFactorRange: [1.25, 1.4]
      },
      {
        radius: "50%",
        widthRange: [110, 130],
        heightFactorRange: [1.02, 1.1]
      }
    ];
    const leadershipTraits = [
      {
        keyword: "Global mindset and cultural intelligence",
        intro:
          "This is the foundation of modern leadership. Effective leaders understand and respect diverse cultures, adapt communication styles across regions, and build trust in multicultural environments."
      },
      {
        keyword: "Strategic vision and foresight",
        intro:
          "Leaders must anticipate long-term global trends, technological shifts, and geopolitical dynamics. The most effective combine vision with agility, pivoting decisively when conditions change."
      },
      {
        keyword: "Resilience and adaptability",
        intro:
          "Emotional toughness and flexibility are core to global leadership. Great leaders maintain composure under pressure, recover quickly from setbacks, and remain steady through uncertainty."
      },
      {
        keyword: "Empathic and authentic communication",
        intro:
          "Leadership depends on the ability to connect meaningfully across languages, cultures, and levels of an organization. The focus is on clarity, empathy, and consistency between message and action."
      },
      {
        keyword: "Emotional intelligence (EQ)",
        intro:
          "Leaders with strong EQ manage their emotions and read others accurately. It drives collaboration, trust, and influence, especially in high-pressure or cross-functional settings."
      },
      {
        keyword: "Integrity and ethical leadership",
        intro:
          "Integrity, transparency, and moral courage are critical to credibility and sustainability, especially in complex global markets."
      }
    ];
    const maxAnchored = 6;

    const balloonField = document.getElementById("balloonField");
    const anchorZone = document.getElementById("anchorZone");
    const anchorSlot = document.getElementById("anchorSlot");
    const anchorCountEl = document.getElementById("anchorCount");
    const anchorMaxEl = document.getElementById("anchorMax");
    const completionOverlay = document.getElementById("completionOverlay");
    const restartButton = document.getElementById("restartGame");
    const openCarouselButton = document.getElementById("openCarousel");
    const carouselModal = document.getElementById("carouselModal");
    const closeCarouselButton = document.getElementById("closeCarousel");
    const carouselTrack = document.getElementById("carouselTrack");
    const carouselPagination = document.getElementById("carouselPagination");
    const prevSlideButton = document.getElementById("prevSlide");
    const nextSlideButton = document.getElementById("nextSlide");
    const carouselViewport = document.querySelector(".carousel-viewport");
    const floatingRestartButton = document.getElementById("floatingRestart");
    const floatingTraitsButton = document.getElementById("floatingTraits");
    const welcomeOverlay = document.getElementById("welcomeOverlay");
    const startGameButton = document.getElementById("startGame");

    anchorMaxEl.textContent = maxAnchored;

    const anchoredBalloons = [];
    const initialPlacements = [];
    let activeBalloon = null;
    let pointerId = null;
    let startOffset = { x: 0, y: 0 };
    let dragStart = { left: 0, top: 0 };
    let fieldRect = null;
    let dragAreaHeight = 0;
    let zIndexSeed = 80;
    let hasCelebrated = false;
    let currentSlide = 0;
    const colorLookup = balloonConfig.reduce((acc, item) => {
      if (!acc[item.keyword]) {
        acc[item.keyword] = item.color;
      }
      return acc;
    }, {});

    const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
    const toTitleCase = (text) =>
      text.replace(/\w\S*/g, (word) => {
        if (word.length > 1 && word === word.toUpperCase()) {
          return word;
        }
        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
      });

    const updateAnchorStatus = () => {
      anchorCountEl.textContent = anchoredBalloons.length;
      anchorZone.classList.toggle("full", anchoredBalloons.length >= maxAnchored);
    };

    const rectanglesOverlap = (a, b, gap = 12) => {
      const expandedA = {
        left: a.left - gap,
        right: a.left + a.width + gap,
        top: a.top - gap,
        bottom: a.top + a.height + gap
      };
      const expandedB = {
        left: b.left - gap,
        right: b.left + b.width + gap,
        top: b.top - gap,
        bottom: b.top + b.height + gap
      };

      return !(
        expandedA.right < expandedB.left ||
        expandedA.left > expandedB.right ||
        expandedA.bottom < expandedB.top ||
        expandedA.top > expandedB.bottom
      );
    };

    const randomizePosition = (el) => {
      const rect = balloonField.getBoundingClientRect();
      const padX = Math.max(rect.width * 0.05, 24);
      const padY = Math.max(rect.height * 0.05, 24);

      const maxX = Math.max(rect.width - padX * 2 - el.offsetWidth, 0);
      const maxY = Math.max(rect.height - padY * 2 - el.offsetHeight, 0);

      let attempts = 0;
      let placed = false;
      let chosenLeft = padX;
      let chosenTop = padY;

      while (attempts < 60 && !placed) {
        const trialLeft = padX + (maxX ? Math.random() * maxX : 0);
        const trialTop = padY + (maxY ? Math.random() * maxY : 0);
        const candidate = {
          left: trialLeft,
          top: trialTop,
          width: el.offsetWidth,
          height: el.offsetHeight
        };

        if (!initialPlacements.some((pos) => rectanglesOverlap(pos, candidate))) {
          placed = true;
          chosenLeft = trialLeft;
          chosenTop = trialTop;
          initialPlacements.push(candidate);
        }

        attempts++;
      }

      if (!placed) {
        chosenLeft = padX + (maxX ? Math.random() * maxX : 0);
        chosenTop = padY + (maxY ? Math.random() * maxY : 0);
        initialPlacements.push({
          left: chosenLeft,
          top: chosenTop,
          width: el.offsetWidth,
          height: el.offsetHeight
        });
      }

      el.style.left = `${chosenLeft}px`;
      el.style.top = `${chosenTop}px`;
    };

    const isOverAnchorZone = (element) => {
      const balloonRect = element.getBoundingClientRect();
      const anchorRect = anchorZone.getBoundingClientRect();

      return !(
        balloonRect.right < anchorRect.left ||
        balloonRect.left > anchorRect.right ||
        balloonRect.bottom < anchorRect.top ||
        balloonRect.top > anchorRect.bottom
      );
    };

    const anchorBalloon = (balloon) => {
      if (anchoredBalloons.includes(balloon)) return;
      anchoredBalloons.push(balloon);
      balloon.classList.add("anchored");
      balloon.dataset.anchored = "true";
      balloon.style.left = "";
      balloon.style.top = "";
      balloon.style.zIndex = "";
      anchorSlot.appendChild(balloon);
      updateAnchorStatus();
      checkCompletionState();
    };

    const pointerDown = (event) => {
      const balloon = event.currentTarget;
      if (balloon.dataset.anchored === "true") return;

      event.preventDefault();
      activeBalloon = balloon;
      pointerId = event.pointerId;
      fieldRect = balloonField.getBoundingClientRect();
      const anchorRect = anchorZone.getBoundingClientRect();
      const totalHeight = anchorRect.bottom - fieldRect.top;
      dragAreaHeight = Math.max(fieldRect.height, totalHeight);

      const rect = balloon.getBoundingClientRect();
      startOffset = { x: event.clientX - rect.left, y: event.clientY - rect.top };
      dragStart = {
        left: parseFloat(balloon.style.left) || 0,
        top: parseFloat(balloon.style.top) || 0
      };

      balloon.style.transition = "none";
      balloon.classList.add("dragging");
      balloon.style.zIndex = ++zIndexSeed;

      balloon.setPointerCapture(pointerId);
      balloon.addEventListener("pointermove", pointerMove);
      balloon.addEventListener("pointerup", pointerUp);
      balloon.addEventListener("pointercancel", pointerUp);
    };

    const pointerMove = (event) => {
      if (!activeBalloon || event.pointerId !== pointerId) return;

      const maxLeft = Math.max(0, fieldRect.width - activeBalloon.offsetWidth);
      const maxTop = Math.max(0, dragAreaHeight - activeBalloon.offsetHeight);

      let newLeft = event.clientX - fieldRect.left - startOffset.x;
      let newTop = event.clientY - fieldRect.top - startOffset.y;

      newLeft = clamp(newLeft, 0, maxLeft);
      newTop = clamp(newTop, 0, maxTop);

      activeBalloon.style.left = `${newLeft}px`;
      activeBalloon.style.top = `${newTop}px`;

      const ready =
        allowedKeywords.includes(activeBalloon.dataset.keyword) &&
        anchoredBalloons.length < maxAnchored &&
        isOverAnchorZone(activeBalloon);

      anchorZone.classList.toggle("ready", ready);
    };

    const pointerUp = (event) => {
      if (!activeBalloon || event.pointerId !== pointerId) return;

      const balloon = activeBalloon;
      balloon.releasePointerCapture(pointerId);
      balloon.removeEventListener("pointermove", pointerMove);
      balloon.removeEventListener("pointerup", pointerUp);
      balloon.removeEventListener("pointercancel", pointerUp);

      balloon.classList.remove("dragging");
      balloon.style.transition = "";
      anchorZone.classList.remove("ready");

      const droppedInAnchor = isOverAnchorZone(balloon);
      const validDrop =
        allowedKeywords.includes(balloon.dataset.keyword) &&
        anchoredBalloons.length < maxAnchored &&
        droppedInAnchor;

      if (validDrop) {
        anchorBalloon(balloon);
      } else {
        if (droppedInAnchor) {
          balloon.style.left = `${dragStart.left}px`;
          balloon.style.top = `${dragStart.top}px`;
        }
        balloon.style.zIndex = "";
      }

      activeBalloon = null;
      pointerId = null;
    };

    const renderCarousel = () => {
      carouselTrack.innerHTML = "";
      leadershipTraits.forEach((trait) => {
        const slide = document.createElement("div");
        slide.className = "carousel-slide";

        const balloon = document.createElement("div");
        balloon.className = "carousel-balloon";
        balloon.style.setProperty("--fill", colorLookup[trait.keyword] || "#ff8f87");
        balloon.textContent = trait.keyword.split(" ")[0] || trait.keyword;

        const content = document.createElement("div");
        content.className = "carousel-content";
        const heading = document.createElement("h3");
        heading.textContent = trait.keyword;
        const copy = document.createElement("p");
        copy.textContent = trait.intro;

        content.appendChild(heading);
        content.appendChild(copy);

        slide.appendChild(balloon);
        slide.appendChild(content);
        carouselTrack.appendChild(slide);
      });
      updateCarousel();
    };

    const updateCarousel = () => {
      const total = leadershipTraits.length;
      currentSlide = (currentSlide + total) % total;
      carouselTrack.style.transform = `translateX(-${currentSlide * 100}%)`;
      carouselPagination.textContent = `${currentSlide + 1} / ${total}`;
    };

    const goToSlide = (index) => {
      const total = leadershipTraits.length;
      currentSlide = (index + total) % total;
      updateCarousel();
    };

    const nextSlide = () => goToSlide(currentSlide + 1);
    const prevSlide = () => goToSlide(currentSlide - 1);

    const showCompletionOverlay = () => {
      completionOverlay.classList.add("active");
      completionOverlay.setAttribute("aria-hidden", "false");
      document.body.classList.add("overlay-open");
    };

    const hideCompletionOverlay = () => {
      if (!completionOverlay.classList.contains("active")) return;
      completionOverlay.classList.remove("active");
      completionOverlay.setAttribute("aria-hidden", "true");
      document.body.classList.remove("overlay-open");
    };

    const openCarouselModal = () => {
      carouselModal.classList.add("active");
      carouselModal.setAttribute("aria-hidden", "false");
      document.body.classList.add("modal-open");
    };

    const closeCarouselModal = () => {
      carouselModal.classList.remove("active");
      carouselModal.setAttribute("aria-hidden", "true");
      document.body.classList.remove("modal-open");
    };

    const checkCompletionState = () => {
      if (!hasCelebrated && anchoredBalloons.length >= maxAnchored) {
        hasCelebrated = true;
        floatingTraitsButton.hidden = false;
        showCompletionOverlay();
      }
    };

    const hideWelcomeOverlay = () => {
      if (!welcomeOverlay) return;
      welcomeOverlay.style.display = "none";
      welcomeOverlay.setAttribute("aria-hidden", "true");
      document.body.classList.remove("overlay-open");
    };

    const showWelcomeOverlay = () => {
      if (!welcomeOverlay) return;
      welcomeOverlay.style.display = "flex";
      welcomeOverlay.setAttribute("aria-hidden", "false");
      document.body.classList.add("overlay-open");
    };

    const handleRestart = () => {
      window.location.reload();
    };

    const handleCarouselOpen = () => {
      if (completionOverlay.classList.contains("active")) {
        hideCompletionOverlay();
      }
      openCarouselModal();
    };

    const handleOverlayClick = (event) => {
      if (event.target === completionOverlay) {
        hideCompletionOverlay();
      }
    };

    const handleModalClick = (event) => {
      if (event.target === carouselModal) {
        closeCarouselModal();
      }
    };

    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        if (carouselModal.classList.contains("active")) {
          closeCarouselModal();
        } else if (completionOverlay.classList.contains("active")) {
          hideCompletionOverlay();
        } else if (welcomeOverlay && welcomeOverlay.style.display !== "none") {
          hideWelcomeOverlay();
        }
      }
    };

    const enableCarouselSwipe = () => {
      let isPointerDown = false;
      let startX = 0;

      const onPointerDown = (event) => {
        isPointerDown = true;
        startX = event.clientX;
      };

      const onPointerUp = (event) => {
        if (!isPointerDown) return;
        const deltaX = event.clientX - startX;
        if (Math.abs(deltaX) > 40) {
          deltaX < 0 ? nextSlide() : prevSlide();
        }
        isPointerDown = false;
      };

      const cancelSwipe = () => {
        isPointerDown = false;
      };

      carouselViewport.addEventListener("pointerdown", onPointerDown);
      carouselViewport.addEventListener("pointerup", onPointerUp);
      carouselViewport.addEventListener("pointerleave", cancelSwipe);
      carouselViewport.addEventListener("pointercancel", cancelSwipe);
    };

    const createBalloon = (data) => {
      const el = document.createElement("div");
      el.className = "balloon";
      el.dataset.keyword = data.keyword;
      el.setAttribute("aria-label", `Balloon ${data.label}`);
      el.style.setProperty("--fill", data.color);

      const profile = balloonProfiles[Math.floor(Math.random() * balloonProfiles.length)];
      const randomWidth =
        profile.widthRange[0] + Math.random() * (profile.widthRange[1] - profile.widthRange[0]);
      const textBoost = Math.min(90, Math.max(0, data.label.length - 18) * 1.5);
      let finalWidth = Math.min(260, Math.max(randomWidth, 135 + textBoost));
      if (data.keyword === "Resourcefulness") {
        finalWidth = Math.min(250, Math.max(finalWidth, 210));
      }
      const heightFactor =
        profile.heightFactorRange[0] +
        Math.random() * (profile.heightFactorRange[1] - profile.heightFactorRange[0]);
      const finalHeight = finalWidth * heightFactor;

      el.style.setProperty("--balloon-width", `${finalWidth}px`);
      el.style.setProperty("--balloon-height", `${finalHeight}px`);
      el.style.setProperty("--balloon-radius", profile.radius);

      const duration = (6 + Math.random() * 2).toFixed(2);
      const delay = (Math.random() * 4).toFixed(2);
      el.style.setProperty("--float-duration", `${duration}s`);
      el.style.setProperty("--float-delay", `${delay}s`);

      const label = document.createElement("span");
      label.className = "balloon-label";
      label.textContent = toTitleCase(data.label);

      el.appendChild(label);

      balloonField.appendChild(el);
      randomizePosition(el);
      el.addEventListener("pointerdown", pointerDown);
    };

    // Init
    balloonConfig.forEach(createBalloon);
    updateAnchorStatus();
    renderCarousel();
    enableCarouselSwipe();
    showWelcomeOverlay();

    restartButton.addEventListener("click", handleRestart);
    floatingRestartButton.addEventListener("click", handleRestart);
    openCarouselButton.addEventListener("click", handleCarouselOpen);
    floatingTraitsButton.addEventListener("click", handleCarouselOpen);
    startGameButton.addEventListener("click", hideWelcomeOverlay);
    completionOverlay.addEventListener("click", handleOverlayClick);
    prevSlideButton.addEventListener("click", prevSlide);
    nextSlideButton.addEventListener("click", nextSlide);
    closeCarouselButton.addEventListener("click", closeCarouselModal);
    carouselModal.addEventListener("click", handleModalClick);
    document.addEventListener("keydown", handleKeyDown);
  </script>
</body>
</html>
